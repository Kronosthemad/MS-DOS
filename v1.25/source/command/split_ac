badcom:
        mov     dx,offset trangroup:badnam
error:
        mov     ah,printbuf
        int     21h
        jmp     command

chkcnt:
        test    [filecnt],-1
        jnz     enddir
        mov     dx,offset trangroup:notfnd
        jmp     error

enddir:
;make sure last line ends with cr/lf
        mov     al,[linlen]
        cmp     al,[lincnt]     ;will be equal if just had cr/lf
        jz      message
        call    crlf2
message:                
        mov     si,[filecnt]
        xor     di,di
        call    disp32bits
        mov     dx,offset trangroup:dirmes
        mov     ah,printbuf
        int     21h
        ret

catalog:
        mov     al,"?"                  ;*.* is default file spec.
        mov     di,5dh
        mov     cx,11
        rep     stosb
        mov     si,81h
        call    switch
        mov     di,5ch
        mov     ax,41*100h+0dh          ;parse with default name and extension
        int     33

;begin by processing any switches that may have been specified.
;bits will contain any information about switches that was
;found when the command line was parsed.

setswt:
        mov     ax,[comsw]              ;get switches from command
        or      ax,[arg1s]              ;or in switches from first parameter
        mov     [bits],ax
        mov     byte ptr[fullscr],linperpag
        test    al,1                    ;look for /w
        mov     al,normperlin
        jz      dir
        mov     al,wideperlin
dir:
        mov     [linlen],al             ;set number of entries per line
        mov     [lincnt],al
        mov     [filecnt],0     ;keep track of how many files found
        mov     dx,offset trangroup:dirbuf      ;set disk transfer address
        mov     ah,setdma
        int     21h             
        mov     ah,srchfrst
showdir:
        mov     dx,5ch          ;dx -> unopened fcb
        int     21h             ;search for a file to match fcb
        inc     al              ;ff = file not found
        jnz     again           ;either an error or we are finished
        jmp     chkcnt
again:
        inc     [filecnt]       ;keep track of how many we find
        mov     si,offset trangroup:dirbuf+1    ;si -> information returned by sys call
        call    shoname
        test    byte ptr[bits],1        ;/w set?
        jnz     nexent          ;if so, no size, date, or time
        call    dispsize        ;print size of file
        call    twospc
        mov     ax,word ptr[dirbuf+25]  ;get date
        or      ax,ax
        jz      nexent          ;skip if no date
        mov     dx,ax
        mov     cl,5
        shr     ax,cl           ;align month
        and     al,0fh
        mov     bh,"0"-" "      ;enable zero suppression
        call    out2
        mov     al,"-"
        call    out
        mov     al,dl
        and     al,1fh          ;mask to day
        call    out2
        mov     al,"-"
        call    out
        mov     al,dh
        shr     al,1            ;align year
        add     ax,80           ;relative 1980
        cmp     al,100
        jb      millenium
        sub     al,100
millenium:
        call    out2
        mov     bx,word ptr[dirbuf+23]  ;get time
        or      bx,bx           ;time field present?
        jz      nexent
        call    twospc  
        shr     bx,1
        shr     bx,1
        shr     bx,1
        shr     bl,1
        shr     bl,1            ;hours in bh, minutes in bl
        mov     al,bh
        mov     dh,"a"          ;assume a.m.
        cmp     al,12           ;in the afternoon?
        jb      morn
        mov     dh,"p"
        je      morn
        sub     al,12           ;keep it to 12 hours or less
morn:
        or      al,al           ;before 1 am?
        jnz     shohours
        mov     al,12
shohours:
        mov     bh,"0"-" "      ;enable zero suppression
        call    out2
        mov     al,":"
        call    out
        mov     al,bl           ;output minutes
        call    out2
        mov     al,dh           ;get "a" or "p"
        call    out
nexent:
        dec     [lincnt]
        jnz     samlin
nexlin:
        mov     al,[linlen]
        mov     [lincnt],al
        call    crlf2
        test    byte ptr[bits],2        ;/p switch present?
        jz      scroll          ;if not, just continue
        dec     byte ptr[fullscr]
        jnz     scroll
        mov     byte ptr[fullscr],linperpag
        mov     ah,printbuf
        mov     dx,offset trangroup:pausmes
        int     33
        mov     ax,0c08h        ;wait for any character to be typed
        int     21h
        call    crlf2
scroll:
        mov     ah,srchnxt
        jmp     showdir

samlin:
        mov     al,9            ;output a tab
        call    out
        jmp     short scroll

shoname:
        mov     cx,8
        call    outcnt
        call    onespc
        mov     cx,3
outcnt:
        lodsb
        call    out
        loop    outcnt
        ret

twospc:
        call    onespc
onespc:
        mov     al," "
        jmp     out

crlf2:
        mov     al,13
        call    out
        mov     al,10
        jmp     out

dispsize:
        mov     si,word ptr[dirbuf+29]
        mov     di,word ptr[dirbuf+31]
disp32bits:
;prints the 32-bit number di:si on the console in decimal. uses a total
;of 9 digit positions with leading blanks.
        xor     ax,ax
        mov     bx,ax
        mov     bp,ax
        mov     cx,32
convlp:
        shl     si,1
        rcl     di,1
        xchg    ax,bp
        call    convwrd
        xchg    ax,bp
        xchg    ax,bx
        call    convwrd
        xchg    ax,bx
        adc     al,0
        loop    convlp
; conversion complete. print 9-digit number.
        mov     cx,1810h        ;allow leading zero blanking for 8 digits
        xchg    dx,ax
        call    digit
        xchg    ax,bx
        call    outword
        xchg    ax,bp
outword:
        push    ax
        mov     dl,ah
        call    outbyte
        pop     dx
outbyte:
        mov     dh,dl
        shr     dl,1
        shr     dl,1
        shr     dl,1
        shr     dl,1
        call    digit
        mov     dl,dh
digit:
        and     dl,0fh
        jz      blankzer
        mov     cl,0
blankzer:
        dec     ch
        and     cl,ch
        or      dl,30h
        sub     dl,cl
        mov     ah,outch
        int     21h
        ret

convwrd:
        adc     al,al
        daa
        xchg    al,ah
        adc     al,al
        daa
        xchg    al,ah
ret20:  ret

erase:
        mov     cx,11
        mov     si,fcb+1
ambspec:        
        lodsb
        cmp     al,"?"
        jnz     allfil
        loop    ambspec
allfil: 
        cmp     cx,0
        jnz     noprmpt
askagn:         
        mov     dx,offset trangroup:suremes     ;"are you sure (y/n)?"
        mov     ah,printbuf
        int     21h
        mov     ax,0c00h+inchar
        int     21h
        and     al,5fh
        cmp     al,"n"
        jz      ret20
        cmp     al,"y"
        call    crlf2
        jz      noprmpt
        jmp     short askagn
noprmpt:
        mov     ah,delete
        mov     bx,offset trangroup:notfnd
        cmp     byte ptr ds:[fcb+1]," " ;check if parameter exists
        jmp     short opfile
rename:
        mov     ah,renam
        mov     bx,offset trangroup:renerr
        cmp     byte ptr ds:[fcb+16+1]," "  ;check if parameter exists
opfile:
        mov     dx,offset trangroup:misnam
        jz      errj            ;error if missing parameter
        mov     dx,fcb
        int     21h
        inc     al
        jnz     ret20
        mov     dx,bx
errj:   jmp     error

typefil:
        mov     ds,[tpa]
        xor     dx,dx
        mov     ah,setdma
        int     21h
        push    cs
        pop     ds
        mov     dx,fcb
        mov     ah,open
        int     21h
        or      al,al
        mov     dx,offset trangroup:notfnd
        jnz     errj
        xor     ax,ax
        mov     word ptr ds:[fcb+rr],ax ;set rr field
        mov     word ptr ds:[fcb+rr+2],ax
        inc     ax
        mov     word ptr ds:[fcb+reclen],ax     ;set record length
        mov     es,[tpa]
typelp:
        mov     dx,fcb
        mov     cx,[bytcnt]
        mov     ah,rdblk
        int     21h
        jcxz    ret30
        xor     si,si           ;start at 0 in tpa
outlp:
        lods    byte ptr es:[si]                ;in tpa segment
        cmp     al,1ah
        jz      ret30
        mov     ah,outch
        mov     dl,al
        int     21h
        loop    outlp
        jmp     short typelp

ret30:  ret                             ;need a nearby ret

copy:
        xor     ax,ax
        mov     [plus],al               ;will keep track of "+"s
        mov     [filecnt],ax
        mov     si,81h                  ;point to input line
        call    switch                  ;skip over switches on command
        mov     bp,ax
        mov     di,fcb
        call    parsnam                 ;scan first source
        mov     [parm1],dl              ;save ambiguous flag
        mov     [srcpt],si              ;save pointer to command line
;parse each name to find destination and check for /v switch
scannam:
        call    parse
        jnz     scannam
getdest:
        mov     di,offset trangroup:dest
        mov     bx,bp                   ;remeber switches so far
        xor     bp,bp                   ;must have dest. swtiches alone
        call    parsnam
        mov     [arg2s],bp              ;remember switches on destination
        jnz     havdestnam              ;file name present?
        inc     di                      ;point to file name spot
        mov     al,"?"                  ;substitute *.*
        mov     cx,11
        rep     stosb
havdestnam:
        or      bx,bp                   ;bx = all switches combined
        and     bl,vswitch              ;verify requested?
        jz      nover
        mov     ax,46*100h+1            ;set verify
        mov     dl,0
        int     33
nover:
        mov     di,offset trangroup:destname
        mov     si,offset trangroup:dest+1
        mov     bx,fcb+1
        call    buildname               ;see if we can make it unambiguous
        mov     di,offset trangroup:destname
        mov     al,"?"
        mov     cx,11
        repne   scasb                   ;scan for "?" to see if ambiguous
        mov     al,1                    ;flag if ambig.
        jz      ambig
        dec     ax                      ;al=0 if unambig.
ambig:
        mov     dl,al
        mov     ah,[plus]               ;1=found "+"
        xor     al,1                    ;0=ambig, 1=unambig destination
        and     al,[parm1]              ;source ambig. and dest unambig.
        or      al,ah                   ;or found "+" means concatenation
        mov     [ascii],al              ;concatenation implies ascii mode
        mov     [inexact],al            ;ascii implies inexact copy
        shl     al,1
        or      al,dl                   ;combine multiple and concat flags
        mov     [parm2],al
        mov     al,byte ptr[comsw]
        call    setasc                  ;check /a,/b on command
        mov     al,byte ptr[arg1s]
        call    setasc                  ;check for ascii on first filename
        mov     byte ptr[comsw],al              ;save starting switch values
        mov     ah,srchfrst
        call    search                  ;search for first source name
multdest:
        jz      firstsrc                ;find a first source name?
        test    [parm2],1               ;if multiple, we're done
        jnz     endcopy
        xor     ax,ax
        mov     [nxtadd],ax
        mov     [cflag],al              ;flag nothing read yet
nextsng:
        mov     di,fcb
        mov     si,[srcpt]
        call    parsesrc                ;parse next file name into fcb
        mov     [parm1],dl              ;remember if it's ambiguous
        mov     [srcpt],si
        jz      sngclos
        mov     ah,srchfrst
        call    search                  ;search for new file name
        jnz     nextsng                 ;if none, skip it and move to next name
readsng:
        call    checkread
sngloop:
        call    searchnext              ;see if any more of this name
        jz      readsng
        jmp     short nextsng

sngclos:
        call    closefil
endcopy:
        mov     si,[filecnt]
        xor     di,di
        call    disp32bits
        mov     dx,offset trangroup:copied
        mov     ah,printbuf
        int     21h
        jmp     command                 ;stack could be messed up

firstsrc:
        mov     si,offset trangroup:dirbuf+1
        mov     di,offset trangroup:source
        mov     cx,11
        rep     movsb                   ;copy first source name to source
        mov     si,offset trangroup:destname
        mov     di,offset trangroup:dest+1
        mov     bx,offset trangroup:source
        call    buildname               ;build destination name
        xor     ax,ax
        mov     [nxtadd],ax
        mov     [cflag],al
        mov     [append],al
        mov     [nowrite],al
        test    [parm2],1               ;multiple destinations?
        jz      noprt
        mov     si,offset trangroup:dirbuf+1
        call    shoname                 ;if so, show first source
        call    crlf2
noprt:
        call    compname                ;source and dest. the same?
        jnz     doread                  ;if not, read source in
        test    [parm2],2               ;concatenation?
        mov     dx,offset trangroup:overwr
        jz      coperrj                 ;if not, overwrite error
        mov     [append],1              ;set physical append
        mov     ah,open
        mov     dx,offset trangroup:dest
        int     33                      ;open (existing) destination
        cmp     [ascii],0               ;ascii flag set?
        jz      binaryapp
;ascii append. must find logical eof, then seek there with dest. fcb
        mov     [nowrite],1
        call    readin                  ;find eof
        call    flshfil                 ;seek there
        mov     [nowrite],0
        call    flshfil                 ;truncate file
        jmp     short snglchk

sngloopj:jmp    sngloop

coperrj:jmp     coperr

binaryapp:
        mov     word ptr[dest+reclen],1         ;set record length to 1
        mov     si,offset trangroup:dest+16             ;point to file size
        mov     di,offset trangroup:dest+rr
        movsw
        movsw                           ;seek to end of file
        mov     [cflag],1
        jmp     short snglchk
doread:
        call    readin
snglchk:
        test    [parm2],1               ;single or multiple destinations?
        jz      sngloopj
        mov     si,[srcpt]
multapp:
        call    parse
        jz      multclos
        push    si
        mov     si,offset trangroup:dirbuf+1
        mov     di,si
        mov     bx,offset trangroup:source
        call    buildname
        call    checkread
        pop     si
        jmp     short multapp
multclos:
        call    closefil
        mov     al,byte ptr[comsw]
        mov     [ascii],al              ;restore ascii flag
        call    searchnext
        jmp     multdest

parse:
        mov     di,offset trangroup:dirbuf
parsesrc:
        call    scanoff
        cmp     al,"+"
        jnz     retzf
