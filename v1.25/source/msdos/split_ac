badfat:
        mov     cx,di
        add     dx,cx
        dec     al
        jnz     nextfat
        call    figfat                          ;reset registers
        call    dread                           ;try first fat once more
        jmp     short newfat

okret1:
        mov     al,0
        ret

close:  ;system call 16
        mov     di,dx
        cmp     byte ptr [di],-1                ;check for extended fcb
        jnz     normfcb3
        add     di,7
normfcb3:
        test    byte ptr [di.devid],0c0h        ;allow only dirty files
        jnz     okret1                          ;can't close if i/o device, or not writen
        mov     al,[di]                         ;get physical unit number
        dec     al                              ;make zero = drive a
        mov     ah,1                            ;look for dirty buffer
        cmp     ax,cs:word ptr [bufdrvno]
        jnz     fnddir
;write back dirty buffer if on same drive
        push    dx
        push    ds
        push    cs
        pop     ds
        mov     byte ptr [dirtybuf],0
        mov     bx,[buffer]
        mov     cx,1
        mov     dx,[bufsecno]
        mov     bp,[bufdrvbp]
        call    dwrite
        pop     ds
        pop     dx
fnddir:
        call    getfile
badclosej:
        jc      badclose
        mov     cx,es:[di.firclus]
        mov     [si],cx
        mov     dx,es:word ptr [di.filsiz]
        mov     [si+2],dx
        mov     dx,es:word ptr [di.filsiz+2]
        mov     [si+4],dx
        mov     dx,es:[di.fdate]
        mov     [si-2],dx
        mov     dx,es:[di.ftime]
        mov     [si-4],dx
        call    dirwrite

chkfatwrt:
; do fatwrt only if fat is dirty and uses same i/o driver
        mov     si,[bp.fat]
        mov     al,[bp.devnum]
        mov     ah,1
        cmp     [si-2],ax       ;see if fat dirty and uses same driver
        jnz     okret

fatwrt:

; inputs:
;       ds = cs
;       bp = base of drive parameter table
; function:
;       write the fat back to disk and reset fat
;       dirty bit.
; outputs:
;       al = 0
;       bp unchanged
; all other registers destroyed

        call    figfat
        mov     byte ptr [bx-1],0
eachfat:
        push    dx
        push    cx
        push    bx
        push    ax
        call    dwrite
        pop     ax
        pop     bx
        pop     cx
        pop     dx
        add     dx,cx
        dec     al
        jnz     eachfat
okret:
        mov     al,0
        ret

badclose:
        mov     si,[bp.fat]
        mov     byte ptr [si-1],0
        mov     al,-1
        ret


figfat:
; loads registers with values needed to read or
; write a fat.
        mov     al,[bp.fatcnt]
        mov     bx,[bp.fat]
        mov     cl,[bp.fatsiz]  ;no. of records occupied by fat
        mov     ch,0
        mov     dx,[bp.firfat]  ;record number of start of fats
        ret


dircomp:
; prepare registers for directory read or write
        cbw
        add     ax,[bp.firdir]
        mov     dx,ax
        mov     bx,offset dosgroup:dirbuf
        mov     cx,1
        ret


create: ;system call 22
        call    movname
        jc      erret3
        mov     di,offset dosgroup:name1
        mov     cx,11
        mov     al,"?"
        repne   scasb
        jz      erret3
        mov     cs:byte ptr [creating],-1
        push    dx
        push    ds
        call    findname
        jnc     existent
        mov     ax,[entfree]    ;first free entry found in findname
        cmp     ax,-1
        jz      errpop
        call    getent          ;point at that free entry
        jmp     short freespot
errpop:
        pop     ds
        pop     dx
erret3:
        mov     al,-1
        ret

existent:
        jnz     errpop          ;error if attributes don't match
        or      bh,bh           ;check if file is i/o device
        js      openjmp         ;if so, no action
        mov     cx,[si]         ;get pointer to clusters
        jcxz    freespot
        cmp     cx,[bp.maxclus]
        ja      freespot
        push    bx
        mov     bx,cx
        mov     si,[bp.fat]
        call    release         ;free any data already allocated
        call    fatwrt
        pop     bx
freespot:
        mov     di,bx
        mov     si,offset dosgroup:name1
        mov     cx,5
        movsb
        rep     movsw
        mov     al,[attrib]
        stosb
        xor     ax,ax
        mov     cl,5
        rep     stosw
        call    date16
        xchg    ax,dx
        stosw
        xchg    ax,dx
        stosw
        xor     ax,ax
        push    di
        mov     cl,6
smallent:
        rep     stosb
        push    bx
        call    dirwrite
        pop     bx
        pop     si
openjmp:
        clc                     ;clear carry so open won't fail
        pop     es
        pop     di
        jmp     doopen


dirread:

; inputs:
;       ds = cs
;       al = directory block number
;       bp = base of drive parameters
; function:
;       read the directory block into dirbuf.
; outputs:
;       ax,bp unchanged
; all other registers destroyed.

        push    ax
        call    chkdirwrite
        pop     ax
        push    ax
        mov     ah,[bp.devnum]
        mov     [dirbufid],ax
        call    dircomp
        call    dread
        pop     ax
ret8:   ret


dread:

; inputs:
;       bx,ds = transfer address
;       cx = number of sectors
;       dx = absolute record number
;       bp = base of drive parameters
; function:
;       calls bios to perform disk read. if bios reports
;       errors, will call harderr for further action.
; bp preserved. all other registers destroyed.

        call    dskread
        jnc     ret8
        mov     cs:byte ptr [readop],0
        call    harderr
        cmp     al,1            ;check for retry
        jz      dread
        ret                     ;ignore otherwise


harderr:

;hard disk error handler. entry conditions:
;       ds:bx = original disk transfer address
;       dx = original logical sector number
;       cx = number of sectors to go (first one gave the error)
;       ax = hardware error code
;       di = original sector transfer count
;       bp = base of drive parameters
;       [readop] = 0 for read, 1 for write

        xchg    ax,di           ;error code in di, count in ax
        sub     ax,cx           ;number of sectors successfully transferred
        add     dx,ax           ;first sector number to retry
        push    dx
        mul     [bp.secsiz]     ;number of bytes transferred
        pop     dx
        add     bx,ax           ;first address for retry
        mov     ah,0            ;flag disk section in error
        cmp     dx,[bp.firfat]  ;in reserved area?
        jb      errint
        inc     ah              ;flag for fat
        cmp     dx,[bp.firdir]  ;in fat?
        jb      errint
        inc     ah
        cmp     dx,[bp.firrec]  ;in directory?
        jb      errint
        inc     ah              ;must be in data area
errint:
        shl     ah,1            ;make room for read/write bit
        or      ah,cs:[readop]
fatal:
        mov     al,[bp.drvnum]  ;get drive number
fatal1:
        push    bp              ;the only thing we preserve
        mov     cs:[contstk],sp
        cli                     ;prepare to play with stack
        mov     ss,cs:[sssave]
        mov     sp,cs:[spsave]  ;user stack pointer restored
        int     24h             ;fatal error interrupt vector
        mov     cs:[spsave],sp
        mov     cs:[sssave],ss
        mov     sp,cs
        mov     ss,sp
        mov     sp,cs:[contstk]
        sti
        pop     bp
        cmp     al,2
        jz      error
        ret

dskread:
        mov     al,[bp.devnum]
        push    bp
        push    bx
        push    cx
        push    dx
        call    far ptr biosread 
        pop     dx
        pop     di
        pop     bx
        pop     bp
ret9:   ret


chkdirwrite:
        test    byte ptr [dirtydir],-1
        jz      ret9

dirwrite:

; inputs:
;       ds = cs
;       al = directory block number
;       bp = base of drive parameters
; function:
;       write the directory block into dirbuf.
; outputs:
;       bp unchanged
; all other registers destroyed.

        mov     byte ptr [dirtydir],0
        mov     al,byte ptr [dirbufid]
        call    dircomp


dwrite:

; inputs:
;       bx,ds = transfer address
;       cx = number of sectors
;       dx = absolute record number
;       bp = base of drive parameters
; function:
;       calls bios to perform disk write. if bios reports
;       errors, will call harderr for further action.
; bp preserved. all other registers destroyed.

        mov     al,[bp.devnum]
        mov     ah,cs:verflg
        push    bp
        push    bx
        push    cx
        push    dx
        call    far ptr bioswrite 
        pop     dx
        pop     di
        pop     bx
        pop     bp
        jnc     ret9
        mov     cs:byte ptr [readop],1
        call    harderr
        cmp     al,1            ;check for retry
        jz      dwrite
        ret


abort:
        lds     si,cs:dword ptr [spsave]
        mov     ds,[si.cssave]
        xor     ax,ax
        mov     es,ax
        mov     si,savexit
        mov     di,exit
        movsw
        movsw
        movsw
        movsw
        movsw
        movsw
error:
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
        call    wrtfats
        xor     ax,ax
        cli
        mov     ss,[sssave]
        mov     sp,[spsave]
        mov     ds,ax
        mov     si,exit
        mov     di,offset dosgroup:exithold
        movsw
        movsw
        pop     ax
        pop     bx
        pop     cx
        pop     dx
        pop     si
        pop     di
        pop     bp
        pop     ds
        pop     es
        sti             ;stack ok now
        jmp     cs:dword ptr [exithold]


seqrd:  ;system call 20
        call    getrec
        call    load
        jmp     short finseq

seqwrt: ;system call 21
        call    getrec
        call    store
finseq:
        jcxz    setnrex
        add     ax,1
        adc     dx,0
        jmp     short setnrex

rndrd:  ;system call 33
        call    getrrpos1
        call    load
        jmp     short finrnd

rndwrt: ;system call 34
        call    getrrpos1
        call    store
        jmp     short finrnd

blkrd:  ;system call 39
        call    getrrpos
        call    load
        jmp     short finblk

blkwrt: ;system call 40
        call    getrrpos
        call    store
finblk:
        lds     si,dword ptr [spsave]
        mov     [si.cxsave],cx
        jcxz    finrnd
        add     ax,1
        adc     dx,0
finrnd:
        mov     es:word ptr [di.rr],ax
        mov     es:[di.rr+2],dl
        or      dh,dh
        jz      setnrex
        mov     es:[di.rr+3],dh ;save 4 byte of recpos only if significant
setnrex:
        mov     cx,ax
        and     al,7fh
        mov     es:[di.nr],al
        and     cl,80h
        shl     cx,1
        rcl     dx,1
        mov     al,ch
        mov     ah,dl
        mov     es:[di.extent],ax
        mov     al,cs:[dskerr]
        ret

getrrpos1:
        mov     cx,1
getrrpos:
        mov     di,dx
        cmp     byte ptr [di],-1
        jnz     normfcb1
        add     di,7
normfcb1:
        mov     ax,word ptr [di.rr]
        mov     dx,word ptr [di.rr+2]
        ret

nofilerr:
        xor     cx,cx
        mov     byte ptr [dskerr],4
        pop     bx
        ret

